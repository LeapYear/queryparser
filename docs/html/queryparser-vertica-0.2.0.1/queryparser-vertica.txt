-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parsing for Vertica SQL queries
--   
--   A library for parsing Vertica SQL queries into analyzable ASTs.
--   
--   This library is to be used with the queryparser library, which
--   provides the common type definitions and analyses across the different
--   SQL dialects.
@package queryparser-vertica
@version 0.2.0.1

module Database.Sql.Vertica.Token
data Token
TokWord :: !Bool -> !Text -> Token
TokString :: !ByteString -> Token
TokNumber :: !Text -> Token
TokSymbol :: !Text -> Token
TokError :: !String -> Token
data WordInfo
WordInfo :: !Bool -> !Bool -> !Bool -> !Bool -> WordInfo
[wordCanBeSchemaName] :: WordInfo -> !Bool
[wordCanBeTableName] :: WordInfo -> !Bool
[wordCanBeColumnName] :: WordInfo -> !Bool
[wordCanBeFunctionName] :: WordInfo -> !Bool
wordInfo :: Text -> WordInfo
instance GHC.Classes.Eq Database.Sql.Vertica.Token.Token
instance GHC.Show.Show Database.Sql.Vertica.Token.Token

module Database.Sql.Vertica.Scanner
isWordBody :: Char -> Bool
isHSpace :: Char -> Bool
operators :: [Text]
isOperator :: Char -> Bool
tokenize :: Text -> [(Token, Position, Position)]

-- | tokString returns Text, not ByteString, because there is no way to put
--   arbitrary byte sequences in this kind of Vertica string (... for now?)
tokString :: Position -> Char -> Text -> Either Position (Text, Text, Position)
tokExtString :: Position -> Text -> Either (Token, Position) (ByteString, Text, Position)
tokName :: Position -> Text -> Either (Token, Position, Position) (Text, Bool, Text, Position)

module Database.Sql.Vertica.Parser.Internal
type Parser = Parsec [(Token, Position, Position)] Integer
getNextCounter :: Parser Integer

module Database.Sql.Vertica.Type
data Vertica
dialectProxy :: Proxy Vertica
data TableInfo r a
TableInfo :: a -> Maybe [Order r a] -> Maybe (TableEncoding r a) -> Maybe (Segmentation r a) -> Maybe (KSafety a) -> Maybe (Partitioning r a) -> TableInfo r a
[tableInfoInfo] :: TableInfo r a -> a
[tableInfoOrdering] :: TableInfo r a -> Maybe [Order r a]
[tableInfoEncoding] :: TableInfo r a -> Maybe (TableEncoding r a)
[tableInfoSegmentation] :: TableInfo r a -> Maybe (Segmentation r a)
[tableInfoKSafety] :: TableInfo r a -> Maybe (KSafety a)
[tableInfoPartitioning] :: TableInfo r a -> Maybe (Partitioning r a)
resolveTableInfo :: TableInfo RawNames a -> Resolver (TableInfo ResolvedNames) a
data VerticaStatement r a
VerticaStandardSqlStatement :: (Statement Vertica r a) -> VerticaStatement r a
VerticaCreateProjectionStatement :: (CreateProjection r a) -> VerticaStatement r a
VerticaMultipleRenameStatement :: (MultipleRename r a) -> VerticaStatement r a
VerticaSetSchemaStatement :: (SetSchema r a) -> VerticaStatement r a
VerticaMergeStatement :: (Merge r a) -> VerticaStatement r a
VerticaUnhandledStatement :: a -> VerticaStatement r a
data TableEncoding r a
TableEncoding :: a -> [(ColumnRef r a, Encoding a)] -> TableEncoding r a
resolveTableEncoding :: TableEncoding RawNames a -> Resolver (TableEncoding ResolvedNames) a
data Segmentation r a
UnsegmentedAllNodes :: a -> Segmentation r a
UnsegmentedOneNode :: a -> (Node a) -> Segmentation r a
SegmentedBy :: a -> (Expr r a) -> (NodeList a) -> Segmentation r a
resolveSegmentation :: Segmentation RawNames a -> Resolver (Segmentation ResolvedNames) a
data Node a
Node :: a -> Text -> Node a
data NodeListOffset a
NodeListOffset :: a -> Int -> NodeListOffset a
data NodeList a
AllNodes :: a -> (Maybe (NodeListOffset a)) -> NodeList a
Nodes :: a -> (NonEmpty (Node a)) -> NodeList a
data KSafety a
KSafety :: a -> (Maybe Int) -> KSafety a
data Partitioning r a
Partitioning :: a -> (Expr r a) -> Partitioning r a
resolvePartitioning :: Partitioning RawNames a -> Resolver (Partitioning ResolvedNames) a
data Encoding a
EncodingAuto :: a -> Encoding a
EncodingBlockDict :: a -> Encoding a
EncodingBlockDictComp :: a -> Encoding a
EncodingBZipComp :: a -> Encoding a
EncodingCommonDeltaComp :: a -> Encoding a
EncodingDeltaRangeComp :: a -> Encoding a
EncodingDeltaVal :: a -> Encoding a
EncodingGCDDelta :: a -> Encoding a
EncodingGZipComp :: a -> Encoding a
EncodingRLE :: a -> Encoding a
EncodingNone :: a -> Encoding a
data CreateProjection r a
CreateProjection :: a -> Maybe a -> ProjectionName a -> Maybe (NonEmpty (ProjectionColumn a)) -> Query r a -> Maybe (Segmentation r a) -> Maybe (KSafety a) -> CreateProjection r a
[createProjectionInfo] :: CreateProjection r a -> a
[createProjectionIfNotExists] :: CreateProjection r a -> Maybe a
[createProjectionName] :: CreateProjection r a -> ProjectionName a
[createProjectionColumns] :: CreateProjection r a -> Maybe (NonEmpty (ProjectionColumn a))
[createProjectionQuery] :: CreateProjection r a -> Query r a
[createProjectionSegmentation] :: CreateProjection r a -> Maybe (Segmentation r a)
[createProjectionKSafety] :: CreateProjection r a -> Maybe (KSafety a)
data ProjectionName a
ProjectionName :: a -> (Maybe (QSchemaName Maybe a)) -> Text -> ProjectionName a
data ProjectionColumn a
ProjectionColumn :: a -> Text -> Maybe (AccessRank a) -> Maybe (Encoding a) -> ProjectionColumn a
[projectionColumnInfo] :: ProjectionColumn a -> a
[projectionColumnName] :: ProjectionColumn a -> Text
[projectionColumnAccessRank] :: ProjectionColumn a -> Maybe (AccessRank a)
[projectionColumnEncoding] :: ProjectionColumn a -> Maybe (Encoding a)
data AccessRank a
AccessRank :: a -> Int -> AccessRank a
data MultipleRename r a
MultipleRename :: a -> [AlterTable r a] -> MultipleRename r a
data SetSchema r a
SetSchema :: a -> TableName r a -> SchemaName r a -> SetSchema r a
[setSchemaInfo] :: SetSchema r a -> a
[setSchemaTable] :: SetSchema r a -> TableName r a
[setSchemaName] :: SetSchema r a -> SchemaName r a
data Merge r a
Merge :: a -> TableName r a -> Maybe (TableAlias a) -> TableName r a -> Maybe (TableAlias a) -> Expr r a -> Maybe (NonEmpty (ColumnRef r a, DefaultExpr r a)) -> Maybe (NonEmpty (ColumnRef r a)) -> Maybe (NonEmpty (DefaultExpr r a)) -> Merge r a
[mergeInfo] :: Merge r a -> a
[mergeTargetTable] :: Merge r a -> TableName r a
[mergeTargetAlias] :: Merge r a -> Maybe (TableAlias a)
[mergeSourceTable] :: Merge r a -> TableName r a
[mergeSourceAlias] :: Merge r a -> Maybe (TableAlias a)
[mergeCondition] :: Merge r a -> Expr r a
[mergeUpdateDirective] :: Merge r a -> Maybe (NonEmpty (ColumnRef r a, DefaultExpr r a))
[mergeInsertDirectiveColumns] :: Merge r a -> Maybe (NonEmpty (ColumnRef r a))
[mergeInsertDirectiveValues] :: Merge r a -> Maybe (NonEmpty (DefaultExpr r a))
decomposeMerge :: forall d a. Merge ResolvedNames a -> NonEmpty (Statement d ResolvedNames a)
resolveVerticaStatement :: VerticaStatement RawNames a -> Resolver (VerticaStatement ResolvedNames) a
resolveMultipleRename :: MultipleRename RawNames a -> Resolver (MultipleRename ResolvedNames) a
resolveSetSchema :: SetSchema RawNames a -> Resolver (SetSchema ResolvedNames) a
typeExample :: ()
instance Data.Traversable.Traversable Database.Sql.Vertica.Type.ProjectionColumn
instance Data.Foldable.Foldable Database.Sql.Vertica.Type.ProjectionColumn
instance GHC.Base.Functor Database.Sql.Vertica.Type.ProjectionColumn
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Vertica.Type.ProjectionColumn a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Vertica.Type.ProjectionColumn a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Vertica.Type.ProjectionColumn a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.ProjectionColumn a)
instance Data.Traversable.Traversable Database.Sql.Vertica.Type.AccessRank
instance Data.Foldable.Foldable Database.Sql.Vertica.Type.AccessRank
instance GHC.Base.Functor Database.Sql.Vertica.Type.AccessRank
instance GHC.Classes.Ord a => GHC.Classes.Ord (Database.Sql.Vertica.Type.AccessRank a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Vertica.Type.AccessRank a)
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Vertica.Type.AccessRank a)
instance GHC.Read.Read a => GHC.Read.Read (Database.Sql.Vertica.Type.AccessRank a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Vertica.Type.AccessRank a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.AccessRank a)
instance Data.Traversable.Traversable Database.Sql.Vertica.Type.ProjectionName
instance Data.Foldable.Foldable Database.Sql.Vertica.Type.ProjectionName
instance GHC.Base.Functor Database.Sql.Vertica.Type.ProjectionName
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Vertica.Type.ProjectionName a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Vertica.Type.ProjectionName a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Vertica.Type.ProjectionName a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.ProjectionName a)
instance Data.Traversable.Traversable Database.Sql.Vertica.Type.Encoding
instance Data.Foldable.Foldable Database.Sql.Vertica.Type.Encoding
instance GHC.Base.Functor Database.Sql.Vertica.Type.Encoding
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Vertica.Type.Encoding a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Vertica.Type.Encoding a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Vertica.Type.Encoding a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.Encoding a)
instance Data.Traversable.Traversable Database.Sql.Vertica.Type.KSafety
instance Data.Foldable.Foldable Database.Sql.Vertica.Type.KSafety
instance GHC.Base.Functor Database.Sql.Vertica.Type.KSafety
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Vertica.Type.KSafety a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Vertica.Type.KSafety a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Vertica.Type.KSafety a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.KSafety a)
instance Data.Traversable.Traversable Database.Sql.Vertica.Type.NodeList
instance Data.Foldable.Foldable Database.Sql.Vertica.Type.NodeList
instance GHC.Base.Functor Database.Sql.Vertica.Type.NodeList
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Vertica.Type.NodeList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Vertica.Type.NodeList a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Vertica.Type.NodeList a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.NodeList a)
instance Data.Traversable.Traversable Database.Sql.Vertica.Type.NodeListOffset
instance Data.Foldable.Foldable Database.Sql.Vertica.Type.NodeListOffset
instance GHC.Base.Functor Database.Sql.Vertica.Type.NodeListOffset
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Vertica.Type.NodeListOffset a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Vertica.Type.NodeListOffset a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Vertica.Type.NodeListOffset a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.NodeListOffset a)
instance Data.Traversable.Traversable Database.Sql.Vertica.Type.Node
instance Data.Foldable.Foldable Database.Sql.Vertica.Type.Node
instance GHC.Base.Functor Database.Sql.Vertica.Type.Node
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Vertica.Type.Node a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Vertica.Type.Node a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Vertica.Type.Node a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.Node a)
instance Data.Data.Data Database.Sql.Vertica.Type.Vertica
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Vertica.Type.TableInfo r a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.TableInfo r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Vertica.Type.TableInfo r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Vertica.Type.TableInfo r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Vertica.Type.TableInfo r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Vertica.Type.TableInfo r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Vertica.Type.TableInfo r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Vertica.Type.VerticaStatement r a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.VerticaStatement r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Vertica.Type.VerticaStatement r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Vertica.Type.VerticaStatement r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Vertica.Type.VerticaStatement r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Vertica.Type.VerticaStatement r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Vertica.Type.VerticaStatement r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Vertica.Type.TableEncoding r a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.TableEncoding r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Vertica.Type.TableEncoding r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Vertica.Type.TableEncoding r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Vertica.Type.TableEncoding r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Vertica.Type.TableEncoding r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Vertica.Type.TableEncoding r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Vertica.Type.Segmentation r a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.Segmentation r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Vertica.Type.Segmentation r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Vertica.Type.Segmentation r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Vertica.Type.Segmentation r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Vertica.Type.Segmentation r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Vertica.Type.Segmentation r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Vertica.Type.Partitioning r a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.Partitioning r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Vertica.Type.Partitioning r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Vertica.Type.Partitioning r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Vertica.Type.Partitioning r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Vertica.Type.Partitioning r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Vertica.Type.Partitioning r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Vertica.Type.CreateProjection r a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.CreateProjection r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Vertica.Type.CreateProjection r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Vertica.Type.CreateProjection r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Vertica.Type.CreateProjection r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Vertica.Type.CreateProjection r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Vertica.Type.CreateProjection r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Vertica.Type.MultipleRename r a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.MultipleRename r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Vertica.Type.MultipleRename r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Vertica.Type.MultipleRename r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Vertica.Type.MultipleRename r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Vertica.Type.MultipleRename r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Vertica.Type.MultipleRename r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Vertica.Type.SetSchema r a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.SetSchema r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Vertica.Type.SetSchema r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Vertica.Type.SetSchema r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Vertica.Type.SetSchema r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Vertica.Type.SetSchema r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Vertica.Type.SetSchema r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Vertica.Type.Merge r a)
instance GHC.Generics.Generic (Database.Sql.Vertica.Type.Merge r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Vertica.Type.Merge r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Vertica.Type.Merge r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Vertica.Type.Merge r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Vertica.Type.Merge r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Vertica.Type.Merge r)
instance Database.Sql.Util.Joins.HasJoins (Database.Sql.Vertica.Type.VerticaStatement Database.Sql.Type.Scope.ResolvedNames a)
instance Database.Sql.Util.Lineage.Table.HasTableLineage (Database.Sql.Vertica.Type.VerticaStatement Database.Sql.Type.Scope.ResolvedNames a)
instance Database.Sql.Util.Lineage.ColumnPlus.HasColumnLineage (Database.Sql.Vertica.Type.VerticaStatement Database.Sql.Type.Scope.ResolvedNames Database.Sql.Position.Range)
instance Database.Sql.Util.Schema.HasSchemaChange (Database.Sql.Vertica.Type.VerticaStatement Database.Sql.Type.Scope.ResolvedNames a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.VerticaStatement r a)
instance Database.Sql.Util.Tables.HasTables (Database.Sql.Vertica.Type.VerticaStatement Database.Sql.Type.Scope.ResolvedNames a)
instance Database.Sql.Util.Columns.HasColumns (Database.Sql.Vertica.Type.VerticaStatement Database.Sql.Type.Scope.ResolvedNames a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.Merge r a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.Merge r a)
instance Database.Sql.Util.Tables.HasTables (Database.Sql.Vertica.Type.Merge Database.Sql.Type.Scope.ResolvedNames a)
instance Database.Sql.Util.Columns.HasColumns (Database.Sql.Vertica.Type.Merge Database.Sql.Type.Scope.ResolvedNames a)
instance Database.Sql.Util.Schema.HasSchemaChange (Database.Sql.Vertica.Type.SetSchema Database.Sql.Type.Scope.ResolvedNames a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.SetSchema r a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.SetSchema r a)
instance Database.Sql.Util.Schema.HasSchemaChange (Database.Sql.Vertica.Type.MultipleRename Database.Sql.Type.Scope.ResolvedNames a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.MultipleRename r a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.MultipleRename r a)
instance Database.Sql.Util.Tables.HasTables (Database.Sql.Vertica.Type.MultipleRename Database.Sql.Type.Scope.ResolvedNames a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.CreateProjection r a)
instance Database.Sql.Util.Columns.HasColumns (Database.Sql.Vertica.Type.CreateProjection Database.Sql.Type.Scope.ResolvedNames a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.ProjectionColumn a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.AccessRank a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.AccessRank a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.ProjectionName a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.ProjectionName a)
instance Database.Sql.Type.Dialect Database.Sql.Vertica.Type.Vertica
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.TableInfo r a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.TableInfo r a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.TableEncoding r a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.TableEncoding r a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.Encoding a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.Encoding a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.Partitioning r a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.Partitioning r a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.KSafety a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.KSafety a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.Segmentation r a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.Segmentation r a)
instance Database.Sql.Util.Columns.HasColumns (Database.Sql.Vertica.Type.Segmentation Database.Sql.Type.Scope.ResolvedNames a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.NodeList a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.NodeList a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.NodeListOffset a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.NodeListOffset a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Vertica.Type.Node a)
instance Database.Sql.Info.HasInfo (Database.Sql.Vertica.Type.Node a)

module Database.Sql.Vertica.Parser.Token
showTok :: (Token, Position, Position) -> String
posFromTok :: (Token, Position, Position) -> SourcePos
tokEqualsP :: Token -> Parser Range
tokNotEqualsP :: Token -> Parser Range
testNameTok :: (Token, Position, Position) -> Maybe (Text, Range)
typeNameP :: Parser (Text, Range)
nodeNameP :: Parser (Text, Range)
databaseNameP :: Parser (Text, Range)
userNameP :: Parser (Text, Range)
paramNameP :: Parser (Text, Range)
windowNameP :: Parser (Text, Range)
parserNameP :: Parser (Text, Range)
datePartP :: Parser (Text, Range)
schemaNameP :: Parser (Text, Range)
tableNameP :: Parser (Text, Range)
projectionNameP :: Parser (Text, Range)
columnNameP :: Parser (Text, Range)
functionNameP :: Parser (Text, Range)
constraintNameP :: Parser (Text, Range)
keywordP :: Text -> Parser Range
fieldTypeP :: Parser (Text, Range)
periodP :: Parser (Text, Range)
stringP :: Parser (ByteString, Range)
numberP :: Parser (Text, Range)
encodingTypeP :: Parser (Encoding Range)
dotP :: Parser Range
equalP :: Parser Range
symbolP :: Text -> Parser Range
starP :: Parser Range
openP :: Parser Range
closeP :: Parser Range
openBracketP :: Parser Range
closeBracketP :: Parser Range
castP :: Parser Range
castOpP :: Parser Range
minusP :: Parser Range
abortP :: Parser Range
accessP :: Parser Range
accessRankP :: Parser Range
addP :: Parser Range
aggregateP :: Parser Range
allP :: Parser Range
alterP :: Parser Range
analyticP :: Parser Range
andP :: Parser Range
anyP :: Parser Range
arrayP :: Parser Range
asP :: Parser Range
ascP :: Parser Range
atP :: Parser Range
authorizationP :: Parser Range
autoP :: Parser Range
beginP :: Parser Range
bestP :: Parser Range
betweenP :: Parser Range
byP :: Parser Range
bytesP :: Parser Range
bzipP :: Parser Range
cascadeP :: Parser Range
caseP :: Parser Range
checkP :: Parser Range
colSizesP :: Parser Range
columnP :: Parser Range
commaP :: Parser Range
commitP :: Parser Range
committedP :: Parser Range
connectP :: Parser Range
constraintP :: Parser Range
copyP :: Parser Range
createP :: Parser Range
crossP :: Parser Range
currentP :: Parser Range
currentDatabaseP :: Parser (Text, Range)
currentDateP :: Parser (Text, Range)
currentSchemaP :: Parser (Text, Range)
currentTimeP :: Parser (Text, Range)
currentTimestampP :: Parser (Text, Range)
currentUserP :: Parser (Text, Range)
dataP :: Parser Range
dateDiffP :: Parser Range
defaultP :: Parser Range
deleteP :: Parser Range
delimiterP :: Parser Range
descP :: Parser Range
directP :: Parser Range
disableP :: Parser Range
disabledP :: Parser Range
disconnectP :: Parser Range
distinctP :: Parser Range
doubleP :: Parser Range
dropP :: Parser Range
elseP :: Parser Range
enableP :: Parser Range
enabledP :: Parser Range
enclosedP :: Parser Range
encodingP :: Parser Range
endP :: Parser Range
enforceLengthP :: Parser Range
errorP :: Parser Range
escapeP :: Parser Range
exceptP :: Parser Range
exceptionsP :: Parser Range
excludeP :: Parser Range
excludingP :: Parser Range
existsP :: Parser Range
explainP :: Parser Range
exportP :: Parser Range
externalP :: Parser Range
extractP :: Parser Range
falseP :: Parser Range
fillerP :: Parser Range
filterP :: Parser Range
firstP :: Parser Range
fixedWidthP :: Parser Range
followingP :: Parser Range
forP :: Parser Range
foreignP :: Parser Range
formatP :: Parser Range
fromP :: Parser Range
fullP :: Parser Range
functionP :: Parser Range
globalP :: Parser Range
grantP :: Parser Range
groupP :: Parser Range
gzipP :: Parser Range
havingP :: Parser Range
ifP :: Parser Range
ignoreP :: Parser Range
iLikeP :: Parser Range
iLikeBP :: Parser Range
inP :: Parser Range
includeP :: Parser Range
includingP :: Parser Range
innerP :: Parser Range
insertP :: Parser Range
intersectP :: Parser Range
intervalP :: Parser Range
intoP :: Parser Range
isP :: Parser Range
isnullP :: Parser Range
isolationP :: Parser Range
joinP :: Parser Range
keyP :: Parser Range
ksafeP :: Parser Range
lastP :: Parser Range
leftP :: Parser Range
levelP :: Parser Range
likeP :: Parser Range
likeBP :: Parser Range
limitP :: Parser Range
localP :: Parser Range
localTimeP :: Parser (Text, Range)
localTimestampP :: Parser (Text, Range)
longP :: Parser Range
lzoP :: Parser Range
matchedP :: Parser Range
mergeP :: Parser Range
nameP :: Parser Range
nativeP :: Parser Range
naturalP :: Parser Range
noP :: Parser Range
nodeP :: Parser Range
nodesP :: Parser Range
notP :: Parser Range
notnullP :: Parser Range
nullsP :: Parser Range
nullsequalP :: Parser Range
nullP :: Parser Range
nullColsP :: Parser Range
offsetP :: Parser Range
onP :: Parser Range
onlyP :: Parser Range
optionP :: Parser Range
orP :: Parser Range
orcP :: Parser Range
orderP :: Parser Range
overlapsP :: Parser Range
outerP :: Parser Range
overP :: Parser Range
parametersP :: Parser Range
parquetP :: Parser Range
parserP :: Parser Range
partitionP :: Parser Range
passwordP :: Parser Range
poolP :: Parser Range
policyP :: Parser Range
precedingP :: Parser Range
precisionP :: Parser Range
preserveP :: Parser Range
primaryP :: Parser Range
privilegesP :: Parser Range
projectionP :: Parser Range
projectionsP :: Parser Range
rangeP :: Parser Range
readP :: Parser Range
recordP :: Parser Range
referencesP :: Parser Range
rejectedP :: Parser Range
rejectMaxP :: Parser Range
renameP :: Parser Range
repeatableP :: Parser Range
replaceP :: Parser Range
resourceP :: Parser Range
restrictP :: Parser Range
revokeP :: Parser Range
rightP :: Parser Range
rollbackP :: Parser Range
rowP :: Parser Range
rowsP :: Parser Range
schemaP :: Parser Range
segmentedP :: Parser Range
selectP :: Parser Range
semicolonP :: Parser Range
notSemicolonP :: Parser Range
setP :: Parser Range
serializableP :: Parser Range
sessionP :: Parser Range
sessionUserP :: Parser (Text, Range)
showP :: Parser Range
skipP :: Parser Range
sourceP :: Parser Range
startP :: Parser Range
stdinP :: Parser Range
stdoutP :: Parser Range
storageP :: Parser Range
streamP :: Parser Range
sysDateP :: Parser (Text, Range)
tableP :: Parser Range
temporaryP :: Parser Range
terminatorP :: Parser Range
thenP :: Parser Range
timeseriesP :: Parser Range
timestampP :: Parser Range
timezoneP :: Parser Range
toleranceP :: Parser Range
trailingP :: Parser Range
transactionP :: Parser Range
transformP :: Parser Range
trickleP :: Parser Range
trimP :: Parser Range
trueP :: Parser Range
truncateP :: Parser Range
toP :: Parser Range
unboundedP :: Parser Range
uncommittedP :: Parser Range
uncompressedP :: Parser Range
unionP :: Parser Range
uniqueP :: Parser Range
unknownP :: Parser Range
unsegmentedP :: Parser Range
updateP :: Parser Range
userP :: Parser (Text, Range)
usingP :: Parser Range
valuesP :: Parser Range
varBinaryP :: Parser (Text, Range)
varCharP :: Parser (Text, Range)
verticaP :: Parser Range
viewP :: Parser Range
whenP :: Parser Range
whereP :: Parser Range
windowP :: Parser Range
withP :: Parser Range
withoutP :: Parser Range
workP :: Parser Range
writeP :: Parser Range
likeOpP :: Parser Range
iLikeOpP :: Parser Range
notLikeOpP :: Parser Range
notILikeOpP :: Parser Range
regexMatchesP :: Parser Range
notRegexMatchesP :: Parser Range
regexIgnoreCaseMatchesP :: Parser Range
notRegexIgnoreCaseMatchesP :: Parser Range
inequalityOpP :: Parser (Text, Range)
equalityOpP :: Parser (Text, Range)

module Database.Sql.Vertica.Parser.Shared
dataTypeP :: Parser (DataType Range)
periodP :: Parser (DataType Range)
constantP :: Parser (Constant Range)
unqualifiedTableNameP :: Parser (UQTableName Range)
qualifiedTableNameP :: Parser (Text, Text, Range, Range)
tableNameP :: Parser (TableRef RawNames Range)
projectionNameP :: Parser (ProjectionName Range)
columnNameP :: Parser (ColumnRef RawNames Range)

module Database.Sql.Vertica.Parser.IngestionOptions
ingestionColumnListP :: Parser Range -> Parser Range
ingestionColumnOptionP :: Parser Range
fileStorageFormatP :: Parser Range
abortOnErrorP :: Parser Range
delimiterAsP :: Parser Range
enclosedByP :: Parser Range
errorToleranceP :: Parser Range
escapeFormatP :: Parser Range
exceptionsOnNodeP :: Parser Range
fileFilterP :: Parser Range
fileParserP :: Parser Range
fileSourceP :: Parser Range
fillerP :: Parser Range
columnStorageFormatP :: Parser Range
noCommitP :: Parser Range
nullAsP :: Parser Range
recordTerminatorP :: Parser Range
rejectedDataOnNodeP :: Parser Range
rejectMaxP :: Parser Range
skipBytesP :: Parser Range
skipRecordsP :: Parser Range
streamNameP :: Parser Range
trailingNullColsP :: Parser Range
trimByteP :: Parser Range
compressionP :: Parser Range
loadMethodP :: Parser Range

module Database.Sql.Vertica.Parser
statementParser :: Parser (VerticaStatement RawNames Range)

-- | parse consumes a statement, or fails
parse :: Text -> Either ParseError (VerticaStatement RawNames Range)

-- | parseAll consumes all input as a single statement, or fails
parseAll :: Text -> Either ParseError (VerticaStatement RawNames Range)

-- | parseMany consumes multiple statements, or fails
parseMany :: Text -> Either ParseError [VerticaStatement RawNames Range]

-- | parseManyAll consumes all input multiple statements, or fails
parseManyAll :: Text -> Either ParseError [VerticaStatement RawNames Range]

-- | parseManyEithers consumes all input as multiple (statements or
--   failures) it should never fail
parseManyEithers :: Text -> Either ParseError [Either (Unparsed Range) (VerticaStatement RawNames Range)]
optionBool :: Parser a -> Parser Bool
statementP :: Parser (Statement Vertica RawNames Range)
oqColumnNameP :: Parser (OQColumnName Range)
insertP :: Parser (Insert RawNames Range)
defaultExprP :: Parser (DefaultExpr RawNames Range)
deleteP :: Parser (Delete RawNames Range)
truncateP :: Parser (Truncate RawNames Range)
querySelectP :: Parser (Query RawNames Range)
queryP :: Parser (Query RawNames Range)
distinctP :: Parser Distinct
explainP :: Parser (Statement Vertica RawNames Range)
columnAliasP :: Parser (ColumnAlias Range)
alterTableP :: Parser (AlterTable RawNames Range)
createSchemaPrefixP :: Parser Range
ifNotExistsP :: Parser (Maybe Range)
ifExistsP :: Parser Range
createSchemaP :: Parser (CreateSchema RawNames Range)
createTableColumnsP :: Parser (TableDefinition Vertica RawNames Range)
createExternalTablePrefixP :: Parser (Range, Externality Range)
createExternalTableP :: Parser (CreateTable Vertica RawNames Range)
createViewPrefixP :: Parser (Range, Maybe Range, Persistence Range)
schemaPrivilegesP :: Parser Range
createViewP :: Parser (CreateView RawNames Range)
createTableP :: Parser (CreateTable Vertica RawNames Range)
dropViewPrefixP :: Parser Range
dropViewP :: Parser (DropView RawNames Range)
dropTableP :: Parser (DropTable RawNames Range)
grantP :: Parser (Grant Range)
revokeP :: Parser (Revoke Range)
beginP :: Parser Range
commitP :: Parser Range
rollbackP :: Parser Range
nodeListP :: Parser (NodeList Range)
nodeListOffsetP :: Parser (NodeListOffset Range)
nodeNameP :: Parser (Node Range)
integerP :: Parser (Int, Range)
selectP :: Parser (Select RawNames Range)
handlePositionalReferences :: Expr RawNames Range -> PositionOrExpr RawNames Range
selectStarP :: Parser (Selection RawNames Range)
selectionP :: Parser (Selection RawNames Range)
makeColumnAlias :: Range -> Text -> Parser (ColumnAlias Range)
makeTableAlias :: Range -> Text -> Parser (TableAlias Range)
makeDummyAlias :: Range -> Parser (ColumnAlias Range)
makeExprAlias :: Expr RawNames Range -> Parser (ColumnAlias Range)
aliasP :: Expr RawNames Range -> Parser (ColumnAlias Range)
exprP :: Parser (Expr RawNames Range)
parenExprP :: Parser (Expr RawNames Range)
subqueryExprP :: Parser (Expr RawNames Range)
caseExprP :: Parser (Expr RawNames Range)
fieldTypeP :: Parser (Expr RawNames Range)
functionExprP :: Parser (Expr RawNames Range)
orderTopLevelP :: Parser (Range, [Order RawNames Range])
orderInWindowClauseP :: Parser [Order RawNames Range]
orderExprP :: Bool -> Bool -> Parser (Range, [Order RawNames Range])
directionP :: Parser (OrderDirection (Maybe Range))
nullsP :: Parser (NullPosition (Maybe Range))
frameP :: Parser (Frame Range)
frameBoundP :: Parser (FrameBound Range)
overP :: Parser (OverSubExpr RawNames Range)
windowExprP :: Range -> Parser (WindowExpr RawNames Range)
partialWindowExprP :: Range -> Parser (PartialWindowExpr RawNames Range)
windowNameP :: Parser (WindowName Range)
partitionP :: Parser (Partition RawNames Range)
existsExprP :: Parser (Expr RawNames Range)
arrayExprP :: Parser (Expr RawNames Range)
castExprP :: Parser (Expr RawNames Range)
atTimeZoneExprP :: Parser (Expr RawNames Range)
unOpP :: Text -> Parser (Expr RawNames Range -> Expr RawNames Range)
negateExprP :: Parser (Expr RawNames Range)
binOpP :: Text -> Parser (Expr RawNames Range -> Expr RawNames Range -> Expr RawNames Range)
exponentExprP :: Parser (Expr RawNames Range)
productExprP :: Parser (Expr RawNames Range)
sumExprP :: Parser (Expr RawNames Range)
notP :: Parser (Expr RawNames Range -> Expr RawNames Range)
isExprP :: Parser (Expr RawNames Range)
appendExprP :: Parser (Expr RawNames Range)
inExprP :: Parser (Expr RawNames Range)
betweenExprP :: Parser (Expr RawNames Range)
overlapsExprP :: Parser (Expr RawNames Range)
likeExprP :: Parser (Expr RawNames Range)
mkBinOp :: (Text, a) -> Expr r a -> Expr r a -> Expr r a
inequalityExprP :: Parser (Expr RawNames Range)
equalityExprP :: Parser (Expr RawNames Range)
notExprP :: Parser (Expr RawNames Range)
andExprP :: Parser (Expr RawNames Range)
orExprP :: Parser (Expr RawNames Range)
singleTableP :: Parser (Tablish RawNames Range)
optionalParensP :: Parser a -> Parser a
manyParensP :: Parser a -> Parser a
tablishP :: Parser (Tablish RawNames Range)
joinP :: Parser (Tablish RawNames Range -> Tablish RawNames Range)
regularJoinP :: Parser (Tablish RawNames Range -> Tablish RawNames Range)
outerJoinTypeP :: Parser (JoinType Range)
innerJoinTypeP :: Parser (JoinType Range)
naturalJoinP :: Parser (Tablish RawNames Range -> Tablish RawNames Range)
crossJoinP :: Parser (Tablish RawNames Range -> Tablish RawNames Range)
createProjectionPrefixP :: Parser Range
createProjectionP :: Parser (CreateProjection RawNames Range)
multipleRenameP :: Parser (MultipleRename RawNames Range)
setSchemaP :: Parser (SetSchema RawNames Range)
renameProjectionP :: Parser Range
alterResourcePoolPrefixP :: Parser Range
alterResourcePoolP :: Parser Range
createResourcePoolPrefixP :: Parser Range
createResourcePoolP :: Parser Range
dropResourcePoolPrefixP :: Parser Range
dropResourcePoolP :: Parser Range
createFunctionPrefixP :: Parser Range
createFunctionP :: Parser Range
alterTableAddConstraintP :: Parser Range
tableConstraintP :: Parser Range
exportToStdoutP :: Parser Range
setSessionPrefixP :: Parser Range
setSessionP :: Parser Range
setTimeZoneP :: Parser Range
connectP :: Parser Range
disconnectP :: Parser Range
createAccessPolicyP :: Parser Range
copyFromP :: Parser Range
showP :: Parser Range
mergeP :: Parser (Merge RawNames Range)
