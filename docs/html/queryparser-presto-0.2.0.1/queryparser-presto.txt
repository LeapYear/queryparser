-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parsing for Presto SQL queries
--   
--   A library for parsing Presto SQL queries into analyzable ASTs.
--   
--   This library is to be used with the queryparser library, which
--   provides the common type definitions and analyses across the different
--   SQL dialects.
@package queryparser-presto
@version 0.2.0.1

module Database.Sql.Presto.Token
data Token
TokWord :: !Bool -> !Text -> Token
TokString :: !ByteString -> Token
TokBinary :: !ByteString -> Token
TokNumber :: !Text -> Token
TokSymbol :: !Text -> Token
TokError :: !String -> Token
data WordInfo
WordInfo :: !Bool -> !Bool -> !Bool -> !Bool -> WordInfo
[wordCanBeSchemaName] :: WordInfo -> !Bool
[wordCanBeTableName] :: WordInfo -> !Bool
[wordCanBeColumnName] :: WordInfo -> !Bool
[wordCanBeFunctionName] :: WordInfo -> !Bool
wordInfo :: Text -> WordInfo
instance GHC.Classes.Eq Database.Sql.Presto.Token.Token
instance GHC.Show.Show Database.Sql.Presto.Token.Token

module Database.Sql.Presto.Scanner
isWordHead :: Char -> Bool
isWordBody :: Char -> Bool
isHSpace :: Char -> Bool
operators :: [Text]
isOperator :: Char -> Bool
tokenize :: Text -> [(Token, Position, Position)]
tokString :: Position -> Char -> Text -> Either Position (Text, Text, Position)
tokBinaryLiteral :: Position -> Text -> Either (String, Position) (ByteString, Text, Position)
tokName :: Position -> Text -> Either (Token, Position, Position) (Text, Bool, Text, Position)
tokNumber :: Text -> ((Token, Int64), Text)

module Database.Sql.Presto.Parser.Internal
type ScopeTableRef = Text
data ParserScope
ParserScope :: Maybe (Set ScopeTableRef) -> ParserScope
[selectTableAliases] :: ParserScope -> Maybe (Set ScopeTableRef)
type Parser = ParsecT [(Token, Position, Position)] Integer (Reader ParserScope)
getNextCounter :: Parser Integer
instance GHC.Show.Show Database.Sql.Presto.Parser.Internal.ParserScope
instance GHC.Classes.Ord Database.Sql.Presto.Parser.Internal.ParserScope
instance GHC.Classes.Eq Database.Sql.Presto.Parser.Internal.ParserScope

module Database.Sql.Presto.Parser.Token
showTok :: (Token, Position, Position) -> String
posFromTok :: SourcePos -> (Token, Position, Position) -> [(Token, Position, Position)] -> SourcePos
tokEqualsP :: Token -> Parser Range
tokNotEqualsP :: Token -> Parser Range
testNameTok :: (Token, Position, Position) -> Maybe (Text, Range)
symbolP :: Text -> Parser Range
keywordP :: Text -> Parser Range
dotP :: Parser Range
starP :: Parser Range
plusP :: Parser Range
minusP :: Parser Range
commaP :: Parser Range
openP :: Parser Range
closeP :: Parser Range
openBracketP :: Parser Range
closeBracketP :: Parser Range
openAngleP :: Parser Range
closeAngleP :: Parser Range
questionMarkP :: Parser Range
stringP :: Parser (ByteString, Range)
binaryLiteralP :: Parser (ByteString, Range)
numberP :: Parser (Text, Range)
typeNameP :: Parser (Text, Range)
intervalFieldP :: Parser (Text, Range)
comparisonOperatorP :: Parser (Text, Range)
comparisonQuantifierP :: Parser (Text, Range)
extractUnitP :: Parser (Text, Range)
typedConstantTypeP :: Parser (Text, Range)
normalFormP :: Parser (Text, Range)
possiblyBareFuncP :: Parser (Text, Range, Bool)
castFuncP :: Parser (CastFailureAction, Range)
databaseNameP :: Parser (Text, Range)
schemaNameP :: Parser (Text, Range)
tableNameP :: Parser (Text, Range)
columnNameP :: Parser (Text, Range)
structFieldNameP :: Parser (Text, Range)
paramNameP :: Parser (Text, Range)
functionNameP :: Parser (Text, Range)
allP :: Parser Range
andP :: Parser Range
arrayP :: Parser Range
asP :: Parser Range
ascP :: Parser Range
atP :: Parser Range
bernoulliP :: Parser Range
betweenP :: Parser Range
byP :: Parser Range
callP :: Parser Range
caseP :: Parser Range
crossP :: Parser Range
cubeP :: Parser Range
currentP :: Parser Range
deleteP :: Parser Range
descP :: Parser Range
describeP :: Parser Range
distinctP :: Parser Range
doubleP :: Parser Range
dropP :: Parser Range
elseP :: Parser Range
endP :: Parser Range
escapeP :: Parser Range
exceptP :: Parser Range
existsP :: Parser Range
explainP :: Parser Range
extractP :: Parser Range
falseP :: Parser Range
filterP :: Parser Range
firstP :: Parser Range
followingP :: Parser Range
forP :: Parser Range
fromP :: Parser Range
fullP :: Parser Range
grantP :: Parser Range
groupP :: Parser Range
groupingP :: Parser Range
havingP :: Parser Range
ifP :: Parser Range
intervalP :: Parser Range
inP :: Parser Range
innerP :: Parser Range
insertP :: Parser Range
intersectP :: Parser Range
intoP :: Parser Range
isP :: Parser Range
joinP :: Parser Range
lastP :: Parser Range
leftP :: Parser Range
likeP :: Parser Range
limitP :: Parser Range
mapP :: Parser Range
naturalP :: Parser Range
normalizeP :: Parser Range
notP :: Parser Range
nullP :: Parser Range
nullsP :: Parser Range
onP :: Parser Range
orP :: Parser Range
orderP :: Parser Range
ordinalityP :: Parser Range
outerP :: Parser Range
overP :: Parser Range
partitionP :: Parser Range
poissonizedP :: Parser Range
positionP :: Parser Range
precedingP :: Parser Range
precisionP :: Parser Range
rangeP :: Parser Range
revokeP :: Parser Range
rightP :: Parser Range
rollupP :: Parser Range
rowP :: Parser Range
rowsP :: Parser Range
selectP :: Parser Range
semicolonP :: Parser Range
notSemicolonP :: Parser Range
setsP :: Parser Range
showP :: Parser Range
substringP :: Parser Range
systemP :: Parser Range
tableP :: Parser Range
tableSampleP :: Parser Range
thenP :: Parser Range
timeP :: Parser Range
timestampP :: Parser Range
timezoneP :: Parser Range
toP :: Parser Range
trueP :: Parser Range
unboundedP :: Parser Range
unionP :: Parser Range
unnestP :: Parser Range
usingP :: Parser Range
valuesP :: Parser Range
viewP :: Parser Range
whenP :: Parser Range
whereP :: Parser Range
withP :: Parser Range

module Database.Sql.Presto.Type
data Presto
dialectProxy :: Proxy Presto
data PrestoStatement r a
PrestoStandardSqlStatement :: (Statement Presto r a) -> PrestoStatement r a
PrestoUnhandledStatement :: a -> PrestoStatement r a
resolvePrestoStatement :: PrestoStatement RawNames a -> Resolver (PrestoStatement ResolvedNames) a
typeExample :: ()
instance Data.Data.Data Database.Sql.Presto.Type.Presto
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Presto.Type.PrestoStatement r a)
instance GHC.Generics.Generic (Database.Sql.Presto.Type.PrestoStatement r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Presto.Type.PrestoStatement r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Presto.Type.PrestoStatement r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Presto.Type.PrestoStatement r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Presto.Type.PrestoStatement r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Presto.Type.PrestoStatement r)
instance Database.Sql.Util.Joins.HasJoins (Database.Sql.Presto.Type.PrestoStatement Database.Sql.Type.Scope.ResolvedNames a)
instance Database.Sql.Util.Lineage.Table.HasTableLineage (Database.Sql.Presto.Type.PrestoStatement Database.Sql.Type.Scope.ResolvedNames a)
instance Database.Sql.Util.Lineage.ColumnPlus.HasColumnLineage (Database.Sql.Presto.Type.PrestoStatement Database.Sql.Type.Scope.ResolvedNames Database.Sql.Position.Range)
instance Database.Sql.Util.Schema.HasSchemaChange (Database.Sql.Presto.Type.PrestoStatement Database.Sql.Type.Scope.ResolvedNames a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Presto.Type.PrestoStatement r a)
instance Database.Sql.Util.Tables.HasTables (Database.Sql.Presto.Type.PrestoStatement Database.Sql.Type.Scope.ResolvedNames a)
instance Database.Sql.Util.Columns.HasColumns (Database.Sql.Presto.Type.PrestoStatement Database.Sql.Type.Scope.ResolvedNames a)
instance Database.Sql.Type.Dialect Database.Sql.Presto.Type.Presto

module Database.Sql.Presto.Parser
statementParser :: Parser (PrestoStatement RawNames Range)
emptyParserScope :: ParserScope

-- | parse consumes a statement, or fails
parse :: Text -> Either ParseError (PrestoStatement RawNames Range)

-- | parseAll consumes all input as a single statement, or fails
parseAll :: Text -> Either ParseError (PrestoStatement RawNames Range)

-- | parseMany consumes multiple statements, or fails
parseMany :: Text -> Either ParseError [PrestoStatement RawNames Range]

-- | parseManyAll consumes all input multiple statements, or fails
parseManyAll :: Text -> Either ParseError [PrestoStatement RawNames Range]

-- | parseManyEithers consumes all input as multiple (statements or
--   failures) it should never fail
parseManyEithers :: Text -> Either ParseError [Either (Unparsed Range) (PrestoStatement RawNames Range)]
statementP :: Parser (Statement Presto RawNames Range)
queryP :: Parser (Query RawNames Range)
queryNoWithP :: Parser (Query RawNames Range)
querySelectP :: Parser (Query RawNames Range)
selectP :: Parser (Select RawNames Range)
distinctP :: Parser Distinct
tableAliases :: Maybe (SelectFrom RawNames Range) -> Set Text
tableNameToTableAlias :: OQTableName Range -> Set Text
introduceAliases :: Set Text -> ParserScope -> ParserScope
fromP :: Parser (SelectFrom RawNames Range)
relationP :: Parser (Tablish RawNames Range)
sampledRelationP :: Parser (Tablish RawNames Range)
tableAliasP :: Parser (TableAlias Range)
columnAliasP :: Parser (ColumnAlias Range)
joinP :: Parser (Tablish RawNames Range -> Tablish RawNames Range)
databaseNameP :: Parser (DatabaseName Range)
unqualifiedSchemaNameP :: Parser (UQSchemaName Range)
schemaNameP :: Parser (SchemaName RawNames Range)
unqualifiedTableNameP :: Parser (UQTableName Range)
tableNameP :: Parser (TableRef RawNames Range)
unqualifiedColumnNameP :: Parser (UQColumnName Range)

-- | parsing of qualified columnNames respects the following rules:
--   
--   1) you need to know what tablishes are in scope when parsing a column
--   ref 2) column refs may only be as qualified as the table that
--   introduced them 3) column refs are greedy w.r.t. dots (if a qualified
--   table name and a CTE have the same prefix, a qualified column ref
--   prefers the table)
--   
--   If a scope is present (i.e. while parsing selections), the table name
--   must be a member of the tableAlias list for the parser to succeed.
--   Otherwise, the column parser fails and execution tries the next parser
--   choice.
--   
--   Should the scope not be set, e.g. when selectP is performing lookahead
--   to build scope, this check is skipped.
columnNameP :: Parser (ColumnRef RawNames Range)
functionNameP :: Parser (FunctionName Range)
selectStarP :: Parser (Selection RawNames Range)
selectionP :: Integer -> Parser (Selection RawNames Range)
countingSepBy1 :: (Integer -> Parser b) -> Parser c -> Parser [b]
makeTableAlias :: Range -> Text -> Parser (TableAlias Range)
makeColumnAlias :: Range -> Text -> Parser (ColumnAlias Range)
makeDummyAlias :: Range -> Integer -> Parser (ColumnAlias Range)
makeExprAlias :: Expr RawNames Range -> Integer -> Parser (ColumnAlias Range)
unOpP :: Text -> Parser (Expr RawNames Range -> Expr RawNames Range)
binOpP :: Text -> Parser (Expr RawNames Range -> Expr RawNames Range -> Expr RawNames Range)
exprP :: Parser (Expr RawNames Range)
orExprP :: Parser (Expr RawNames Range)
andExprP :: Parser (Expr RawNames Range)
notP :: Parser (Expr RawNames Range -> Expr RawNames Range)
notExprP :: Parser (Expr RawNames Range)
predicatedExprP :: Parser (Expr RawNames Range)
valueExprP :: Parser (Expr RawNames Range)
concatExprP :: Parser (Expr RawNames Range)
sumExprP :: Parser (Expr RawNames Range)
productExprP :: Parser (Expr RawNames Range)
negateExprP :: Parser (Expr RawNames Range)
intervalP :: Parser (Expr RawNames Range)
atTimeZoneExprP :: Parser (Expr RawNames Range)
stringConstantP :: Parser (Expr RawNames Range)
primaryExprP :: Parser (Expr RawNames Range)
extractPrimaryExprP :: Parser (Expr RawNames Range)
normalizePrimaryExprP :: Parser (Expr RawNames Range)
substringPrimaryExprP :: Parser (Expr RawNames Range)
bareFuncPrimaryExprP :: Parser (Expr RawNames Range)
arrayPrimaryExprP :: Parser (Expr RawNames Range)
dataTypeP :: Parser (DataType Range)
castPrimaryExprP :: Parser (Expr RawNames Range)
casePrimaryExprP :: Parser (Expr RawNames Range)
existsPrimaryExprP :: Parser (Expr RawNames Range)
subqueryPrimaryExprP :: Parser (Expr RawNames Range)
functionCallPrimaryExprP :: Parser (Expr RawNames Range)
overP :: Parser (OverSubExpr RawNames Range)
orderTopLevelP :: Parser (Range, [Order RawNames Range])
orderInWindowClauseP :: Parser [Order RawNames Range]
orderExprP :: Bool -> Bool -> Parser (Range, [Order RawNames Range])
rowPrimaryExprP :: Parser (Expr RawNames Range)
implicitRowPrimaryExprP :: Parser (Expr RawNames Range)
positionPrimaryExprP :: Parser (Expr RawNames Range)
parameterPrimaryExprP :: Parser (Expr RawNames Range)
binaryLiteralPrimaryExprP :: Parser (Expr RawNames Range)
constantPrimaryExprP :: Parser (Expr RawNames Range)
numberExprP :: Parser (Expr RawNames Range)
numberConstantP :: Parser (Constant Range)
columnRefPrimaryExprP :: Parser (Expr RawNames Range)
structAccessP :: Parser (Expr RawNames Range -> Expr RawNames Range)
arrayAccessP :: Parser (Expr RawNames Range -> Expr RawNames Range)
predicateP :: Parser (Expr RawNames Range -> Expr RawNames Range)
optionalNotWrapper :: Parser (Expr RawNames Range -> Expr RawNames Range)
isPredicateP :: Parser (Expr RawNames Range -> Expr RawNames Range)
likePredicateP :: Parser (Expr RawNames Range -> Expr RawNames Range)
inPredicateP :: Parser (Expr RawNames Range -> Expr RawNames Range)
betweenPredicateP :: Parser (Expr RawNames Range -> Expr RawNames Range)
quantifiedComparisonPredicateP :: Parser (Expr RawNames Range -> Expr RawNames Range)
unquantifiedComparisonPredicateP :: Parser (Expr RawNames Range -> Expr RawNames Range)
whereP :: Parser (SelectWhere RawNames Range)
handlePositionalReferences :: Expr RawNames Range -> PositionOrExpr RawNames Range
groupP :: Parser (SelectGroup RawNames Range)
havingP :: Parser (SelectHaving RawNames Range)
deleteP :: Parser (Delete RawNames Range)
dropViewPrefixP :: Parser Range
dropViewP :: Parser (DropView RawNames Range)
dropTableP :: Parser (DropTable RawNames Range)
ifExistsP :: Parser Range
grantP :: Parser (Grant Range)
revokeP :: Parser (Revoke Range)
insertP :: Parser (Insert RawNames Range)
explainP :: Parser Range
showP :: Parser Range
callP :: Parser Range
describeP :: Parser Range
