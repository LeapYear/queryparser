-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parsing for Hive SQL queries
--   
--   A library for parsing Hive SQL queries into analyzable ASTs.
--   
--   This library is to be used with the queryparser library, which
--   provides the common type definitions and analyses across the different
--   SQL dialects.
@package queryparser-hive
@version 0.2.0.1

module Database.Sql.Hive.Token
data Token
TokWord :: !Bool -> !Text -> Token
TokString :: !ByteString -> Token
TokNumber :: !Text -> Token
TokSymbol :: !Text -> Token
TokVariable :: !Text -> VariableName -> Token
TokError :: !String -> Token
data VariableName
StaticName :: !Text -> VariableName
DynamicName :: Token -> VariableName
data WordInfo
WordInfo :: !Bool -> !Bool -> !Bool -> !Bool -> WordInfo
[wordCanBeSchemaName] :: WordInfo -> !Bool
[wordCanBeTableName] :: WordInfo -> !Bool
[wordCanBeColumnName] :: WordInfo -> !Bool
[wordCanBeFunctionName] :: WordInfo -> !Bool
wordInfo :: Text -> WordInfo
instance GHC.Classes.Eq Database.Sql.Hive.Token.Token
instance GHC.Show.Show Database.Sql.Hive.Token.Token
instance GHC.Classes.Eq Database.Sql.Hive.Token.VariableName
instance GHC.Show.Show Database.Sql.Hive.Token.VariableName

module Database.Sql.Hive.Scanner
isWordBody :: Char -> Bool
isHSpace :: Char -> Bool
operators :: [Text]
isOperator :: Char -> Bool
isPlusOrMinus :: Text -> Bool
parseNumber :: Text -> ((Token, Int64), Text)
tokenize :: Text -> [(Token, Position, Position)]
tokUnquotedWord :: Position -> Text -> (Text, Text, Position)
tokQuotedWord :: Position -> Text -> Either Position (Text, Text, Position)
tokString :: Char -> Position -> Text -> Either (Token, Position) (ByteString, Text, Position)
parseVariable :: Text -> ((Token, Int64), Text)

module Database.Sql.Hive.Parser.Internal
type ScopeTableRef = Text
data ParserScope
ParserScope :: Maybe (Set ScopeTableRef) -> ParserScope
[selectTableAliases] :: ParserScope -> Maybe (Set ScopeTableRef)
type Parser = ParsecT [(Token, Position, Position)] Integer (Reader ParserScope)
getNextCounter :: Parser Integer
instance GHC.Show.Show Database.Sql.Hive.Parser.Internal.ParserScope
instance GHC.Classes.Ord Database.Sql.Hive.Parser.Internal.ParserScope
instance GHC.Classes.Eq Database.Sql.Hive.Parser.Internal.ParserScope

module Database.Sql.Hive.Parser.Token
showTok :: (Token, Position, Position) -> String
posFromTok :: SourcePos -> (Token, Position, Position) -> [(Token, Position, Position)] -> SourcePos
tokEqualsP :: Token -> Parser Range
tokNotEqualsP :: Token -> Parser Range
testNameTok :: (Token, Position, Position) -> Maybe (Text, Range)
variableSubstitutionP :: Parser Range
typeNameP :: Parser (Text, Range)
nodeNameP :: Parser (Text, Range)
structFieldNameP :: Parser (Text, Range)
windowNameP :: Parser (Text, Range)
datePartP :: Parser (Text, Range)
schemaNameP :: Parser (Text, Range)
tableNameP :: Parser (Text, Range)
projectionNameP :: Parser (Text, Range)
columnNameP :: Parser (Text, Range)
functionNameP :: Parser (Text, Range)
propertyValuePartP :: Parser (Text, Range)
propertyNameP :: Parser (Text, Range)
textUntilP :: [Text] -> Parser (Text, Range)
keywordP :: Text -> Parser Range
fieldTypeP :: Parser (Text, Range)
periodP :: Parser (Text, Range)
byteAmountP :: Parser (Text, Range)
stringP :: Parser (ByteString, Range)
numberP :: Parser (Text, Range)
dotP :: Parser Range
equalP :: Parser Range
colonP :: Parser Range
symbolP :: Text -> Parser Range
starP :: Parser Range
openP :: Parser Range
closeP :: Parser Range
openBracketP :: Parser Range
closeBracketP :: Parser Range
openAngleP :: Parser Range
closeAngleP :: Parser Range
castP :: Parser Range
castOpP :: Parser Range
minusP :: Parser Range
accessRankP :: Parser Range
addP :: Parser Range
afterP :: Parser Range
allP :: Parser Range
alterP :: Parser Range
analyzeP :: Parser Range
andP :: Parser Range
arrayP :: Parser Range
asP :: Parser Range
ascP :: Parser Range
atP :: Parser Range
autoP :: Parser Range
avroP :: Parser Range
bestP :: Parser Range
betweenP :: Parser Range
bucketP :: Parser Range
bucketsP :: Parser Range
byP :: Parser Range
cacheP :: Parser Range
cascadeP :: Parser Range
caseP :: Parser Range
changeP :: Parser Range
clusterP :: Parser Range
clusteredP :: Parser Range
collectionP :: Parser Range
columnP :: Parser Range
columnsP :: Parser Range
commaP :: Parser Range
commentP :: Parser Range
commitP :: Parser Range
computeP :: Parser Range
createP :: Parser Range
crossP :: Parser Range
cubeP :: Parser Range
currentP :: Parser Range
currentDatabaseP :: Parser (Text, Range)
currentDateP :: Parser (Text, Range)
currentSchemaP :: Parser (Text, Range)
currentTimeP :: Parser (Text, Range)
currentTimestampP :: Parser (Text, Range)
currentUserP :: Parser (Text, Range)
dataP :: Parser Range
databaseP :: Parser Range
dateDiffP :: Parser Range
dbPropertiesP :: Parser Range
defaultP :: Parser Range
definedP :: Parser Range
deleteP :: Parser Range
delimitedP :: Parser Range
descP :: Parser Range
describeP :: Parser Range
directoryP :: Parser Range
distinctP :: Parser Range
distributeP :: Parser Range
dropP :: Parser Range
elseP :: Parser Range
encodingP :: Parser Range
endP :: Parser Range
escapeP :: Parser Range
escapedP :: Parser Range
excludingP :: Parser Range
existsP :: Parser Range
explainP :: Parser Range
externalP :: Parser Range
extractP :: Parser Range
falseP :: Parser Range
fieldsP :: Parser Range
firstP :: Parser Range
followingP :: Parser Range
forP :: Parser Range
formatP :: Parser Range
fromP :: Parser Range
functionP :: Parser Range
fullP :: Parser Range
globalP :: Parser Range
grantP :: Parser Range
groupP :: Parser Range
groupingP :: Parser Range
havingP :: Parser Range
ifP :: Parser Range
ignoreP :: Parser Range
inP :: Parser Range
includingP :: Parser Range
inPathP :: Parser Range
innerP :: Parser Range
inputFormatP :: Parser Range
insertP :: Parser Range
intervalP :: Parser Range
intoP :: Parser Range
isP :: Parser Range
itemsP :: Parser Range
joinP :: Parser Range
keysP :: Parser Range
ksafeP :: Parser Range
lastP :: Parser Range
lateralP :: Parser Range
leftP :: Parser Range
likeP :: Parser Range
limitP :: Parser Range
linesP :: Parser Range
loadP :: Parser Range
localP :: Parser Range
localTimeP :: Parser (Text, Range)
localTimestampP :: Parser (Text, Range)
locationP :: Parser Range
mapP :: Parser Range
metadataP :: Parser Range
noP :: Parser Range
nodeP :: Parser Range
nodesP :: Parser Range
noScanP :: Parser Range
notP :: Parser Range
notOperatorP :: Parser Range
nullP :: Parser Range
nullsP :: Parser Range
nullsequalP :: Parser Range
ofP :: Parser Range
offsetP :: Parser Range
onP :: Parser Range
orP :: Parser Range
orcP :: Parser Range
orderP :: Parser Range
overlapsP :: Parser Range
overwriteP :: Parser Range
outP :: Parser Range
outerP :: Parser Range
outputFormatP :: Parser Range
overP :: Parser Range
parametersP :: Parser Range
parquetP :: Parser Range
partitionP :: Parser Range
partitionedP :: Parser Range
percentP :: Parser Range
precedingP :: Parser Range
preserveP :: Parser Range
projectionP :: Parser Range
projectionsP :: Parser Range
protectionP :: Parser Range
purgeP :: Parser Range
randP :: Parser Range
rangeP :: Parser Range
rcFileP :: Parser Range
regexpP :: Parser Range
reloadP :: Parser Range
renameP :: Parser Range
restrictP :: Parser Range
revokeP :: Parser Range
rlikeP :: Parser Range
rightP :: Parser Range
rollbackP :: Parser Range
rollupP :: Parser Range
rowP :: Parser Range
rowsP :: Parser Range
schemaP :: Parser Range
segmentedP :: Parser Range
selectP :: Parser Range
semicolonP :: Parser Range
notSemicolonP :: Parser Range
semiP :: Parser Range
sessionUserP :: Parser (Text, Range)
sequenceFileP :: Parser Range
serdeP :: Parser Range
serdePropertiesP :: Parser Range
setP :: Parser Range
setsP :: Parser Range
showP :: Parser Range
sortP :: Parser Range
sortedP :: Parser Range
statisticsP :: Parser Range
storedP :: Parser Range
structP :: Parser Range
sysDateP :: Parser (Text, Range)
tableP :: Parser Range
tableSampleP :: Parser Range
tblPropertiesP :: Parser Range
temporaryP :: Parser Range
terminatedP :: Parser Range
textFileP :: Parser Range
thenP :: Parser Range
timeseriesP :: Parser Range
timestampP :: Parser Range
toP :: Parser Range
trueP :: Parser Range
truncateP :: Parser Range
unboundedP :: Parser Range
unionP :: Parser Range
uniontypeP :: Parser Range
unknownP :: Parser Range
unsegmentedP :: Parser Range
useP :: Parser Range
userP :: Parser (Text, Range)
valuesP :: Parser Range
viewP :: Parser Range
whenP :: Parser Range
whereP :: Parser Range
windowP :: Parser Range
withP :: Parser Range
inequalityOpP :: Parser (Text, Range)
equalityOpP :: Parser (Text, Range)

module Database.Sql.Hive.Type
data Hive
dialectProxy :: Proxy Hive
data HiveStatement r a
HiveStandardSqlStatement :: (Statement Hive r a) -> HiveStatement r a
HiveUseStmt :: (Use a) -> HiveStatement r a
HiveAnalyzeStmt :: (Analyze r a) -> HiveStatement r a
HiveInsertDirectoryStmt :: (InsertDirectory r a) -> HiveStatement r a
HiveTruncatePartitionStmt :: (TruncatePartition r a) -> HiveStatement r a
HiveAlterTableSetLocationStmt :: (AlterTableSetLocation r a) -> HiveStatement r a
HiveAlterPartitionSetLocationStmt :: (AlterPartitionSetLocation r a) -> HiveStatement r a
HiveSetPropertyStmt :: (SetProperty a) -> HiveStatement r a
HiveUnhandledStatement :: a -> HiveStatement r a
data SetProperty a
SetProperty :: (SetPropertyDetails a) -> SetProperty a
PrintProperties :: a -> Text -> SetProperty a
data SetPropertyDetails a
SetPropertyDetails :: a -> Text -> Text -> SetPropertyDetails a
[setPropertyDetailsInfo] :: SetPropertyDetails a -> a
[setPropertyDetailsName] :: SetPropertyDetails a -> Text
[setPropertyDetailsValue] :: SetPropertyDetails a -> Text
data HiveCreateTableExtra r a
HiveCreateTableExtra :: a -> Maybe (HiveMetadataProperties a) -> HiveCreateTableExtra r a
[hiveCreateTableExtraInfo] :: HiveCreateTableExtra r a -> a
[hiveCreateTableExtraTableProperties] :: HiveCreateTableExtra r a -> Maybe (HiveMetadataProperties a)
data HiveMetadataProperties a
HiveMetadataProperties :: a -> [HiveMetadataProperty a] -> HiveMetadataProperties a
[hiveMetadataPropertiesInfo] :: HiveMetadataProperties a -> a
[hiveMetadataPropertiesProperties] :: HiveMetadataProperties a -> [HiveMetadataProperty a]
data HiveMetadataProperty a
HiveMetadataProperty :: a -> ByteString -> ByteString -> HiveMetadataProperty a
[hiveMetadataPropertyInfo] :: HiveMetadataProperty a -> a
[hiveMetadataPropertyKey] :: HiveMetadataProperty a -> ByteString
[hiveMetadataPropertyValue] :: HiveMetadataProperty a -> ByteString
data Use a
UseDatabase :: (UQSchemaName a) -> Use a
UseDefault :: a -> Use a
data Analyze r a
Analyze :: a -> TableName r a -> Analyze r a
[analyzeInfo] :: Analyze r a -> a
[analyzeTable] :: Analyze r a -> TableName r a
data InsertDirectory r a
InsertDirectory :: a -> InsertDirectoryLocale a -> Location a -> Query r a -> InsertDirectory r a
[insertDirectoryInfo] :: InsertDirectory r a -> a
[insertDirectoryLocale] :: InsertDirectory r a -> InsertDirectoryLocale a
[insertDirectoryPath] :: InsertDirectory r a -> Location a
[insertDirectoryQuery] :: InsertDirectory r a -> Query r a
data Location a
HDFSPath :: a -> ByteString -> Location a
data InsertDirectoryLocale a
InsertDirectoryLocal :: a -> InsertDirectoryLocale a
InsertDirectoryHDFS :: InsertDirectoryLocale a
data StaticPartitionSpecItem r a
StaticPartitionSpecItem :: a -> (ColumnRef r a) -> (Constant a) -> StaticPartitionSpecItem r a
data DynamicPartitionSpecItem r a
DynamicPartitionSpecItem :: a -> (ColumnRef r a) -> DynamicPartitionSpecItem r a
data TruncatePartition r a
TruncatePartition :: a -> Truncate r a -> TruncatePartition r a
[truncatePartitionInfo] :: TruncatePartition r a -> a
[truncatePartitionTruncate] :: TruncatePartition r a -> Truncate r a
data AlterTableSetLocation r a
AlterTableSetLocation :: a -> TableName r a -> Location a -> AlterTableSetLocation r a
[alterTableSetLocationInfo] :: AlterTableSetLocation r a -> a
[alterTableSetLocationTable] :: AlterTableSetLocation r a -> TableName r a
[alterTableSetLocationLocation] :: AlterTableSetLocation r a -> Location a
data AlterPartitionSetLocation r a
AlterPartitionSetLocation :: a -> TableName r a -> [StaticPartitionSpecItem r a] -> Location a -> AlterPartitionSetLocation r a
[alterPartitionSetLocationInfo] :: AlterPartitionSetLocation r a -> a
[alterPartitionSetLocationTable] :: AlterPartitionSetLocation r a -> TableName r a
[alterPartitionSetLocationPartition] :: AlterPartitionSetLocation r a -> [StaticPartitionSpecItem r a]
[alterPartitionSetLocationLocation] :: AlterPartitionSetLocation r a -> Location a
resolveHiveStatement :: HiveStatement RawNames a -> Resolver (HiveStatement ResolvedNames) a
resolveAnalyze :: Analyze RawNames a -> Resolver (Analyze ResolvedNames) a
resolveInsertDirectory :: InsertDirectory RawNames a -> Resolver (InsertDirectory ResolvedNames) a
resolveTruncatePartition :: TruncatePartition RawNames a -> Resolver (TruncatePartition ResolvedNames) a
resolveAlterTableSetLocation :: AlterTableSetLocation RawNames a -> Resolver (AlterTableSetLocation ResolvedNames) a
resolveAlterPartitionSetLocation :: AlterPartitionSetLocation RawNames a -> Resolver (AlterPartitionSetLocation ResolvedNames) a
typeExample :: ()
bsToJSON :: ByteString -> Value
instance Data.Traversable.Traversable Database.Sql.Hive.Type.InsertDirectoryLocale
instance Data.Foldable.Foldable Database.Sql.Hive.Type.InsertDirectoryLocale
instance GHC.Base.Functor Database.Sql.Hive.Type.InsertDirectoryLocale
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Hive.Type.InsertDirectoryLocale a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Hive.Type.InsertDirectoryLocale a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Hive.Type.InsertDirectoryLocale a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.InsertDirectoryLocale a)
instance Data.Traversable.Traversable Database.Sql.Hive.Type.Location
instance Data.Foldable.Foldable Database.Sql.Hive.Type.Location
instance GHC.Base.Functor Database.Sql.Hive.Type.Location
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Hive.Type.Location a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Hive.Type.Location a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Hive.Type.Location a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.Location a)
instance Data.Traversable.Traversable Database.Sql.Hive.Type.Use
instance Data.Foldable.Foldable Database.Sql.Hive.Type.Use
instance GHC.Base.Functor Database.Sql.Hive.Type.Use
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Hive.Type.Use a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Hive.Type.Use a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Hive.Type.Use a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.Use a)
instance Data.Traversable.Traversable Database.Sql.Hive.Type.HiveMetadataProperties
instance Data.Foldable.Foldable Database.Sql.Hive.Type.HiveMetadataProperties
instance GHC.Base.Functor Database.Sql.Hive.Type.HiveMetadataProperties
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Hive.Type.HiveMetadataProperties a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Hive.Type.HiveMetadataProperties a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Hive.Type.HiveMetadataProperties a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.HiveMetadataProperties a)
instance Data.Traversable.Traversable Database.Sql.Hive.Type.HiveMetadataProperty
instance Data.Foldable.Foldable Database.Sql.Hive.Type.HiveMetadataProperty
instance GHC.Base.Functor Database.Sql.Hive.Type.HiveMetadataProperty
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Hive.Type.HiveMetadataProperty a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Hive.Type.HiveMetadataProperty a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Hive.Type.HiveMetadataProperty a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.HiveMetadataProperty a)
instance Data.Traversable.Traversable Database.Sql.Hive.Type.SetProperty
instance Data.Foldable.Foldable Database.Sql.Hive.Type.SetProperty
instance GHC.Base.Functor Database.Sql.Hive.Type.SetProperty
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Hive.Type.SetProperty a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Hive.Type.SetProperty a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Hive.Type.SetProperty a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.SetProperty a)
instance Data.Traversable.Traversable Database.Sql.Hive.Type.SetPropertyDetails
instance Data.Foldable.Foldable Database.Sql.Hive.Type.SetPropertyDetails
instance GHC.Base.Functor Database.Sql.Hive.Type.SetPropertyDetails
instance GHC.Show.Show a => GHC.Show.Show (Database.Sql.Hive.Type.SetPropertyDetails a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Sql.Hive.Type.SetPropertyDetails a)
instance Data.Data.Data a => Data.Data.Data (Database.Sql.Hive.Type.SetPropertyDetails a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.SetPropertyDetails a)
instance Data.Data.Data Database.Sql.Hive.Type.Hive
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Hive.Type.HiveStatement r a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.HiveStatement r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Hive.Type.HiveStatement r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Hive.Type.HiveStatement r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Hive.Type.HiveStatement r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Hive.Type.HiveStatement r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Hive.Type.HiveStatement r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Hive.Type.HiveCreateTableExtra r a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.HiveCreateTableExtra r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Hive.Type.HiveCreateTableExtra r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Hive.Type.HiveCreateTableExtra r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Hive.Type.HiveCreateTableExtra r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Hive.Type.HiveCreateTableExtra r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Hive.Type.HiveCreateTableExtra r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Hive.Type.Analyze r a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.Analyze r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Hive.Type.Analyze r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Hive.Type.Analyze r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Hive.Type.Analyze r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Hive.Type.Analyze r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Hive.Type.Analyze r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Hive.Type.InsertDirectory r a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.InsertDirectory r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Hive.Type.InsertDirectory r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Hive.Type.InsertDirectory r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Hive.Type.InsertDirectory r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Hive.Type.InsertDirectory r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Hive.Type.InsertDirectory r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Hive.Type.StaticPartitionSpecItem r a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.StaticPartitionSpecItem r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Hive.Type.StaticPartitionSpecItem r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Hive.Type.StaticPartitionSpecItem r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Hive.Type.StaticPartitionSpecItem r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Hive.Type.StaticPartitionSpecItem r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Hive.Type.StaticPartitionSpecItem r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Hive.Type.DynamicPartitionSpecItem r a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.DynamicPartitionSpecItem r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Hive.Type.DynamicPartitionSpecItem r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Hive.Type.DynamicPartitionSpecItem r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Hive.Type.DynamicPartitionSpecItem r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Hive.Type.DynamicPartitionSpecItem r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Hive.Type.DynamicPartitionSpecItem r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Hive.Type.TruncatePartition r a)
instance GHC.Generics.Generic (Database.Sql.Hive.Type.TruncatePartition r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Hive.Type.TruncatePartition r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Hive.Type.TruncatePartition r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Hive.Type.TruncatePartition r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Hive.Type.TruncatePartition r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Hive.Type.TruncatePartition r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Hive.Type.AlterTableSetLocation r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Hive.Type.AlterTableSetLocation r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Hive.Type.AlterTableSetLocation r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Hive.Type.AlterTableSetLocation r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Hive.Type.AlterTableSetLocation r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Hive.Type.AlterTableSetLocation r)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Data.Data r a, Data.Data.Data r) => Data.Data.Data (Database.Sql.Hive.Type.AlterPartitionSetLocation r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Hive.Type.AlterPartitionSetLocation r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Hive.Type.AlterPartitionSetLocation r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Hive.Type.AlterPartitionSetLocation r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Hive.Type.AlterPartitionSetLocation r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Hive.Type.AlterPartitionSetLocation r)
instance Database.Sql.Util.Joins.HasJoins (Database.Sql.Hive.Type.HiveStatement Database.Sql.Type.Scope.ResolvedNames a)
instance Database.Sql.Util.Lineage.Table.HasTableLineage (Database.Sql.Hive.Type.HiveStatement Database.Sql.Type.Scope.ResolvedNames a)
instance Database.Sql.Util.Lineage.ColumnPlus.HasColumnLineage (Database.Sql.Hive.Type.HiveStatement Database.Sql.Type.Scope.ResolvedNames Database.Sql.Position.Range)
instance Database.Sql.Util.Schema.HasSchemaChange (Database.Sql.Hive.Type.HiveStatement Database.Sql.Type.Scope.ResolvedNames a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.HiveStatement r a)
instance Database.Sql.Util.Tables.HasTables (Database.Sql.Hive.Type.HiveStatement Database.Sql.Type.Scope.ResolvedNames a)
instance Database.Sql.Util.Columns.HasColumns (Database.Sql.Hive.Type.HiveStatement Database.Sql.Type.Scope.ResolvedNames a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.AlterPartitionSetLocation r a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.AlterTableSetLocation r a)
instance Database.Sql.Util.Tables.HasTables (Database.Sql.Hive.Type.AlterTableSetLocation Database.Sql.Type.Scope.ResolvedNames a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.TruncatePartition r a)
instance Database.Sql.Info.HasInfo (Database.Sql.Hive.Type.TruncatePartition r a)
instance Database.Sql.Util.Tables.HasTables (Database.Sql.Hive.Type.TruncatePartition Database.Sql.Type.Scope.ResolvedNames a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.StaticPartitionSpecItem r a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.InsertDirectory r a)
instance Database.Sql.Util.Tables.HasTables (Database.Sql.Hive.Type.InsertDirectory Database.Sql.Type.Scope.ResolvedNames a)
instance Database.Sql.Util.Columns.HasColumns (Database.Sql.Hive.Type.InsertDirectory Database.Sql.Type.Scope.ResolvedNames a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.InsertDirectoryLocale a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.Location a)
instance Database.Sql.Info.HasInfo (Database.Sql.Hive.Type.Location a)
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.Analyze r a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.Use a)
instance Database.Sql.Type.Dialect Database.Sql.Hive.Type.Hive
instance (Database.Sql.Type.Names.ConstrainSNames Data.Aeson.Types.ToJSON.ToJSON r a, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.HiveCreateTableExtra r a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.HiveMetadataProperties a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.HiveMetadataProperty a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.SetProperty a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Sql.Hive.Type.SetPropertyDetails a)

module Database.Sql.Hive.Parser
statementParser :: Parser (HiveStatement RawNames Range)
emptyParserScope :: ParserScope

-- | parse consumes a statement, or fails
parse :: Text -> Either ParseError (HiveStatement RawNames Range)

-- | parseAll consumes all input as a single statement, or fails
parseAll :: Text -> Either ParseError (HiveStatement RawNames Range)

-- | parseMany consumes multiple statements, or fails
parseMany :: Text -> Either ParseError [HiveStatement RawNames Range]

-- | parseManyAll consumes all input multiple statements, or fails
parseManyAll :: Text -> Either ParseError [HiveStatement RawNames Range]

-- | parseManyEithers consumes all input as multiple (statements or
--   failures) it should never fail
parseManyEithers :: Text -> Either ParseError [Either (Unparsed Range) (HiveStatement RawNames Range)]
optionBool :: Parser a -> Parser Bool
statementP :: Parser (Statement Hive RawNames Range)
useP :: Parser (Use Range)
analyzeP :: Parser (Analyze RawNames Range)
insertDirectoryPrefixP :: Parser (Range, InsertDirectoryLocale Range, Location Range)
insertDirectoryP :: (QueryPrefix, InvertedFrom) -> Parser (InsertDirectory RawNames Range)
insertDirectoryLocaleP :: Parser (InsertDirectoryLocale Range)
insertDirectoryPathP :: Parser (Location Range)
staticPartitionSpecItemP :: Parser (StaticPartitionSpecItem RawNames Range)
staticPartitionSpecP :: Parser ([StaticPartitionSpecItem RawNames Range], Range)
type PartitionDecider = (Either (StaticPartitionSpecItem RawNames Range) (DynamicPartitionSpecItem RawNames Range))
dynamicPartitionSpecItemP :: Parser (DynamicPartitionSpecItem RawNames Range)
partitionSpecDeciderP :: Parser PartitionDecider
partitionSpecP :: Parser ()
truncatePartitionStatementP :: Parser (TruncatePartition RawNames Range)
describeP :: Parser Range
showP :: Parser Range
createFunctionPrefixP :: Parser Range
createFunctionP :: Parser Range
dropFunctionPrefixP :: Parser Range
dropFunctionP :: Parser Range
alterTableSetLocationP :: Parser (AlterTableSetLocation RawNames Range)
alterTableSetTblPropertiesP :: Parser Range
alterPartitionP :: Parser (HiveStatement RawNames Range)
setP :: Parser (SetProperty Range)
reloadFunctionP :: Parser Range
insertBehaviorHelper :: InsertBehavior Range -> Maybe (TablePartition) -> InsertBehavior Range
insertP :: (QueryPrefix, InvertedFrom) -> Parser (Insert RawNames Range)
loadDataInPathP :: Parser (Insert RawNames Range)
deleteP :: Parser (Delete RawNames Range)
truncateP :: Parser (Truncate RawNames Range)
type QueryPrefix = Query RawNames Range -> Query RawNames Range
emptyPrefix :: QueryPrefix
withP :: Parser QueryPrefix
querySelectP :: (QueryPrefix, InvertedFrom) -> Parser (Query RawNames Range)
queryP :: (QueryPrefix, InvertedFrom) -> Parser (Query RawNames Range)
queryPHelper :: QueryPrefix -> InvertedFrom -> Bool -> Parser (Query RawNames Range)
distinctP :: Parser Distinct
explainP :: Parser (Statement Hive RawNames Range)
tableAliasP :: Parser (TableAlias Range)
columnAliasP :: Parser (ColumnAlias Range)
createSchemaPrefixP :: Parser Range
ifNotExistsP :: Parser (Maybe Range)
commentP :: Parser Range
locationP :: Parser (Location Range)
createSchemaP :: Parser (CreateSchema RawNames Range)
createViewPrefixP :: Parser Range
createViewP :: Parser (CreateView RawNames Range)
data CreateTablePrefix r a
CreateTablePrefix :: a -> Persistence a -> Externality a -> Maybe a -> CreateTableName r a -> CreateTablePrefix r a
[createTablePrefixInfo] :: CreateTablePrefix r a -> a
[createTablePrefixPersistence] :: CreateTablePrefix r a -> Persistence a
[createTablePrefixExternality] :: CreateTablePrefix r a -> Externality a
[createTablePrefixIfNotExists] :: CreateTablePrefix r a -> Maybe a
[createTablePrefixName] :: CreateTablePrefix r a -> CreateTableName r a
createTablePrefixP :: Parser (CreateTablePrefix RawNames Range)
createTableP :: Parser (CreateTable Hive RawNames Range)
createTableLikeP :: Parser (CreateTable Hive RawNames Range)
propertyP :: Parser (HiveMetadataProperty Range)
storedAsP :: Parser Range
createTableStandardP :: Parser (CreateTable Hive RawNames Range)
tblPropertiesP :: Parser (HiveMetadataProperties Range)
delimitedP :: Parser Range
ifExistsP :: Parser Range
dropTableP :: Parser (DropTable RawNames Range)
alterTableRenameTablePrefixP :: Parser (Range, TableName RawNames Range)
alterTableRenameTableP :: Parser (AlterTable RawNames Range)
alterTableRenameColumnPrefixP :: Parser (Range, TableName RawNames Range)
unqualifiedColumnNameP :: Parser (UQColumnName Range)
alterTableRenameColumnP :: Parser (AlterTable RawNames Range)
alterTableAddColumnsPrefixP :: Parser (Range, TableName RawNames Range)
alterTableAddColumnsP :: Parser (AlterTable RawNames Range)
grantP :: Parser (Grant Range)
revokeP :: Parser (Revoke Range)
integerP :: Parser (Int, Range)
countingSepBy1 :: (Integer -> Parser b) -> Parser c -> Parser [b]
introduceAliases :: Set Text -> ParserScope -> ParserScope
tablishToTableAlias :: Tablish RawNames Range -> Set Text
tableNameToTableAlias :: OQTableName Range -> Set Text
fromP :: Parser (SelectFrom RawNames Range)
type InvertedFrom = Maybe (SelectFrom RawNames Range)
noInversion :: InvertedFrom
invertedFromP :: Parser InvertedFrom
selectP :: InvertedFrom -> Parser (Select RawNames Range)
handlePositionalReferences :: Expr RawNames Range -> PositionOrExpr RawNames Range
selectGroupP :: Parser (SelectGroup RawNames Range)

-- | <a>selectClusterP</a> parses for either clusterby or
--   distributeby/sortby T478023 - implement clusterby in select datatype
selectClusterP :: Parser ()
qualifiedTableNameP :: Parser (Text, Text, Range, Range)

-- | The columnName parser has been overhauled with checks for table names.
--   If a scope is present (i.e. in a select statement), the table name
--   must be a member of the tableAlias list for the parser to succeed.
--   Otherwise, the table parser fails and execution tries the next parser
--   choice.
--   
--   Should the scope not be set, e.g. when selectP is performing lookahead
--   to build scope, this check is skipped.
checkTableNameInScopeP :: Text -> Parser ()
selectStarP :: Parser (Selection RawNames Range)
tableNameP :: Parser (OQTableName Range)
arrayAccessP :: Parser (Expr RawNames Range -> Expr RawNames Range)
structFieldNameP :: Parser (StructFieldName Range)
structAccessP :: Parser (Expr RawNames Range -> Expr RawNames Range)
columnNameP :: Parser (OQColumnName Range)
selectionP :: Integer -> Parser (Selection RawNames Range)
makeColumnAlias :: Range -> Text -> Parser (ColumnAlias Range)
makeTableAlias :: Range -> Text -> Parser (TableAlias Range)
makeDummyAlias :: Range -> Integer -> Parser (ColumnAlias Range)
makeExprAlias :: Expr RawNames Range -> Integer -> Parser (ColumnAlias Range)
exprP :: Parser (Expr RawNames Range)
parenExprP :: Parser (Expr RawNames Range)
caseExprP :: Parser (Expr RawNames Range)
fieldTypeP :: Parser (Expr RawNames Range)
functionExprP :: Parser (Expr RawNames Range)
orderTopLevelP :: Parser (Range, [Order RawNames Range])
orderInWindowClauseP :: Parser [Order RawNames Range]
orderExprP :: Bool -> Bool -> Parser (Range, [Order RawNames Range])
directionP :: Parser (OrderDirection (Maybe Range))
nullsP :: Parser (NullPosition (Maybe Range))
frameP :: Parser (Frame Range)
frameBoundP :: Parser (FrameBound Range)
overP :: Parser (OverSubExpr RawNames Range)
windowExprP :: Range -> Parser (WindowExpr RawNames Range)
partialWindowExprP :: Range -> Parser (PartialWindowExpr RawNames Range)
windowNameP :: Parser (WindowName Range)
partitionP :: Parser (Partition RawNames Range)
dataTypeP :: Parser (DataType Range)
existsExprP :: Parser (Expr RawNames Range)
columnExprP :: Parser (Expr RawNames Range)
variableSubstitutionP :: Parser (Expr RawNames Range)
exprWithArrayOrStructAccessP :: Parser (Expr RawNames Range)
unOpP :: Text -> Parser (Expr RawNames Range -> Expr RawNames Range)
unaryPrefixExprP :: Parser (Expr RawNames Range)
notOperatorP :: Parser (Expr RawNames Range -> Expr RawNames Range)
unarySuffixExprP :: Parser (Expr RawNames Range)
binOpP :: Text -> Parser (Expr RawNames Range -> Expr RawNames Range -> Expr RawNames Range)
bitwiseXorExprP :: Parser (Expr RawNames Range)
productExprP :: Parser (Expr RawNames Range)
sumExprP :: Parser (Expr RawNames Range)
stringExprP :: Parser (Expr RawNames Range)
bitwiseAndExprP :: Parser (Expr RawNames Range)
bitwiseOrExprP :: Parser (Expr RawNames Range)
inExprP :: Parser (Expr RawNames Range)
betweenExprP :: Parser (Expr RawNames Range)
likeExprP :: Parser (Expr RawNames Range)
mkBinOp :: (Text, a) -> Expr r a -> Expr r a -> Expr r a
inequalityExprP :: Parser (Expr RawNames Range)
equalityExprP :: Parser (Expr RawNames Range)
notExprP :: Parser (Expr RawNames Range)
andExprP :: Parser (Expr RawNames Range)
orExprP :: Parser (Expr RawNames Range)
singleTableP :: Parser (Tablish RawNames Range)
singleTableWithViewsP :: Parser (Tablish RawNames Range)
lateralViewP :: Parser (Tablish RawNames Range -> Tablish RawNames Range)
optionalParensP :: Parser a -> Parser a
manyParensP :: Parser a -> Parser a
tablishP :: Parser (Tablish RawNames Range)
joinP :: Parser (Tablish RawNames Range -> Tablish RawNames Range)
outerJoinTypeP :: Parser (JoinType Range)
innerJoinTypeP :: Parser (JoinType Range)
crossJoinTypeP :: Parser (JoinType Range)
semiJoinTypeP :: Parser (JoinType Range)
constantP :: Parser (Constant Range)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Classes.Eq r a => GHC.Classes.Eq (Database.Sql.Hive.Parser.CreateTablePrefix r a)
instance Database.Sql.Type.Names.ConstrainSNames GHC.Show.Show r a => GHC.Show.Show (Database.Sql.Hive.Parser.CreateTablePrefix r a)
instance Database.Sql.Type.Names.ConstrainSASNames GHC.Base.Functor r => GHC.Base.Functor (Database.Sql.Hive.Parser.CreateTablePrefix r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Foldable.Foldable r => Data.Foldable.Foldable (Database.Sql.Hive.Parser.CreateTablePrefix r)
instance Database.Sql.Type.Names.ConstrainSASNames Data.Traversable.Traversable r => Data.Traversable.Traversable (Database.Sql.Hive.Parser.CreateTablePrefix r)
